// Generated by CoffeeScript 1.4.0
var BoxObject, GamePlay, KeyboardController, LevelState, LevelView, LiftObject, Observable, PlayerObject, SkyObject, StaticLevelObject, View, boxMeshes, boxTextures, createTextures, e3d, levelTextures, liftMeshes, liftTextures, loadFilesUsing, loadImageFile, loadImageFiles, loadJsonFile, loadJsonFiles, loadResourceFiles, makeBackFace, makeBox, makeFrontFace, makeLeftFace, makeLidlessBox, makeQuad, makeRightFace, makeTopFace, mat, playerMeshes, playerTextures, resource_dir, setBoxTextures, setLevelTextures, setLiftTextures, setPlayerTextures, setSkyTextures, skyMeshes, skyTextures, vec,
  __hasProp = {}.hasOwnProperty;

GamePlay = function() {
  var levelState;
  return levelState = new LevelState(levels.test);
};

KeyboardController = function(levelState) {
  return $(document).on('keydown', function(e) {
    switch (e.which) {
      case 37:
        return levelState.movePlayer('left');
      case 38:
        return levelState.movePlayer('up');
      case 39:
        return levelState.movePlayer('right');
      case 40:
        return levelState.movePlayer('down');
    }
  });
};

LevelState = function(levelData) {
  var BoxBlock, EmptyBlock, LiftBlock, PlatformBlock, Player, SolidBlock, block, blockArray, blockAt, blockBelow, depth, forEach, forEachBlock, forEachBlockInLayer, height, layer, movePlayer, player, row, width, x, y, z;
  EmptyBlock = function(x, y, z) {
    this.type = 'empty';
    this["static"] = false;
    this.position = [x, y, z];
    this.moveableToFrom = function() {
      return blockBelow(this.position[0], this.position[1], this.position[2]).type !== 'empty';
    };
    this.moveToFrom = function(position) {
      var block;
      block = blockAt(position[0], position[1], position[2]);
      blockArray[position[2]][position[1]][position[0]] = this;
      blockArray[this.position[2]][this.position[1]][this.position[0]] = block;
      block.position = this.position;
      return this.position = position;
    };
  };
  SolidBlock = function() {
    this.type = 'solid';
    this["static"] = true;
    this.moveableToFrom = function(position) {
      return false;
    };
  };
  PlatformBlock = function() {
    this.type = 'platform';
    this["static"] = true;
    this.moveableToFrom = function(position) {
      return false;
    };
  };
  BoxBlock = function() {
    this.type = 'box';
    this["static"] = false;
  };
  LiftBlock = function(x, y, z) {
    this.type = 'lift';
    this["static"] = false;
    this.position = [x, y, z];
    this.start = z;
    this.stop = z;
  };
  Player = function(x, y, z) {
    var move;
    this.type = 'player';
    this["static"] = false;
    this.position = [x, y, z];
    move = function(direction) {
      var newPosition, targetBlock;
      newPosition = vec.add(this.position, direction);
      targetBlock = blockAt(newPosition[0], newPosition[1], newPosition[2]);
      if (targetBlock.moveableToFrom(this.position)) {
        targetBlock.moveToFrom(from);
        return true;
      } else {
        return false;
      }
    };
  };
  forEach = function(type, callback) {
    var block, layer, result, row, x, y, z, _i, _j, _k, _len, _len1, _len2;
    result = [];
    for (z = _i = 0, _len = blockArray.length; _i < _len; z = ++_i) {
      layer = blockArray[z];
      for (y = _j = 0, _len1 = layer.length; _j < _len1; y = ++_j) {
        row = layer[y];
        for (x = _k = 0, _len2 = row.length; _k < _len2; x = ++_k) {
          block = row[x];
          if (block.type === type) {
            result.push(callback(block, x, y, z));
          }
        }
      }
    }
    return result;
  };
  forEachBlock = function(callback) {
    var block, layer, row, x, y, z, _i, _len, _results;
    _results = [];
    for (z = _i = 0, _len = blockArray.length; _i < _len; z = ++_i) {
      layer = blockArray[z];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (y = _j = 0, _len1 = layer.length; _j < _len1; y = ++_j) {
          row = layer[y];
          _results1.push((function() {
            var _k, _len2, _results2;
            _results2 = [];
            for (x = _k = 0, _len2 = row.length; _k < _len2; x = ++_k) {
              block = row[x];
              _results2.push(callback(block, x, y, z));
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };
  forEachBlockInLayer = function(layer, callback) {
    var block, row, x, y, _i, _len, _ref, _results;
    _ref = blockArray[layer];
    _results = [];
    for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
      row = _ref[y];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          block = row[x];
          _results1.push(callback(block, x, y));
        }
        return _results1;
      })());
    }
    return _results;
  };
  blockAt = function(x, y, z) {
    if (x < 0 || x >= width) {
      return new EmptyBlock;
    }
    if (y < 0 || y >= depth) {
      return new EmptyBlock;
    }
    if (z < 0 || z >= height) {
      return new EmptyBlock;
    }
    return blockArray[z][y][x];
  };
  blockBelow = function(x, y, z) {
    var block;
    while (--z >= 0) {
      block = blockAt(x, y, z);
      if (block.type !== 'empty') {
        return block;
      }
    }
    return new EmptyBlock;
  };
  movePlayer = function(direction) {
    var positionOffset;
    switch (direction) {
      case 'left':
        positionOffset = [-1, 0, 0];
        break;
      case 'up':
        positionOffset = [0, -1, 0];
        break;
      case 'right':
        positionOffset = [1, 0, 0];
        break;
      case 'down':
        positionOffset = [0, 1, 0];
    }
    return player.move(positionOffset);
  };
  player = null;
  blockArray = (function() {
    var _i, _len, _results;
    _results = [];
    for (z = _i = 0, _len = levelData.length; _i < _len; z = ++_i) {
      layer = levelData[z];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (y = _j = 0, _len1 = layer.length; _j < _len1; y = ++_j) {
          row = layer[y];
          _results1.push((function() {
            var _k, _len2, _results2;
            _results2 = [];
            for (x = _k = 0, _len2 = row.length; _k < _len2; x = ++_k) {
              block = row[x];
              switch (block) {
                case 'O':
                  _results2.push(new SolidBlock);
                  break;
                case 'X':
                  _results2.push(new PlatformBlock);
                  break;
                case 'B':
                  _results2.push(new BoxBlock);
                  break;
                case '^':
                  _results2.push(new LiftBlock);
                  break;
                case 'S':
                  _results2.push(player = new Player(x, y, z));
                  break;
                default:
                  _results2.push(new EmptyBlock(x, y, z));
              }
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  })();
  height = blockArray.length;
  depth = blockArray[0].length;
  width = blockArray[0][0].length;
  forEach('lift', function(lift, x, y, z) {
    var below;
    below = blockBelow(x, y, z);
    if (below.type === 'lift') {
      below.stop = z;
      return blockArray[z][y][x] = new EmptyBlock;
    }
  });
  this.height = height;
  this.depth = depth;
  this.width = width;
  this.player = player;
  this.forEach = forEach;
  this.forEachBlock = forEachBlock;
  this.forEachBlockInLayer = forEachBlockInLayer;
  this.blockAt = blockAt;
  this.blockBelow = blockBelow;
};

Observable = function() {
  this.observerList = [];
  return this.notifyObservers = function(context) {
    var observer, _i, _len, _ref, _results;
    _ref = this.observerList;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      observer = _ref[_i];
      if (observer != null) {
        _results.push(observer.update(context));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
};

resource_dir = 'res/';

loadImageFile = function(filename, callback) {
  var image;
  image = new Image;
  image.onload = function() {
    return callback(image);
  };
  return image.src = resource_dir + filename;
};

loadJsonFile = function(filename, callback) {
  var request;
  request = new XMLHttpRequest;
  request.open('GET', resource_dir + filename, true);
  request.onreadystatechange = function() {
    var data;
    if (request.readyState === 4) {
      data = JSON.parse(request.responseText);
      return callback(data);
    }
  };
  return request.send();
};

loadFilesUsing = function(loadFilesFunc, filenames, callback) {
  var entry, filename, key, loaded, nLoaded, nTotal, _results;
  if (filenames instanceof Object === false) {
    filename = filenames;
    return loadFilesFunc(filename, callback);
  } else {
    if (filenames instanceof Array) {
      nTotal = filenames.length;
      loaded = [];
    } else {
      nTotal = 0;
      for (key in filenames) {
        if (!__hasProp.call(filenames, key)) continue;
        nTotal++;
      }
      loaded = {};
    }
    nLoaded = 0;
    _results = [];
    for (key in filenames) {
      if (!__hasProp.call(filenames, key)) continue;
      entry = filenames[key];
      _results.push((function(key) {
        return loadFilesUsing(loadFilesFunc, entry, function(data) {
          loaded[key] = data;
          if (++nLoaded === nTotal) {
            return callback(loaded);
          }
        });
      })(key));
    }
    return _results;
  }
};

loadImageFiles = function(filenames, callback) {
  return loadFilesUsing(loadImageFile, filenames, callback);
};

loadJsonFiles = function(filenames, callback) {
  return loadFilesUsing(loadJsonFile, filenames, callback);
};

loadResourceFiles = function(filenames, callback) {
  var imagesLoaded, jsonLoaded, loaded;
  imagesLoaded = false;
  jsonLoaded = false;
  loaded = {};
  loadImageFiles(filenames.images, function(images) {
    loaded.images = images;
    imagesLoaded = true;
    if (jsonLoaded) {
      return callback(loaded);
    }
  });
  return loadJsonFiles(filenames.json, function(json) {
    loaded.json = json;
    jsonLoaded = true;
    if (imagesLoaded) {
      return callback(loaded);
    }
  });
};

e3d = e3d || {};

e3d.Camera = function() {
  var aspect, eye, far, fovy, near, target, up;
  this.position = [0, 0, 0];
  this.rotation = [0, 0, 0];
  this.distance = 0;
  fovy = 45;
  aspect = e3d.width / e3d.height;
  near = 0.1;
  far = 100;
  eye = [0, 0, 0];
  target = [0, -1, 0];
  up = [0, 0, 1];
  this.createMatrix = function() {
    var matrix;
    matrix = mat.perspective(fovy, aspect, near, far);
    matrix = mat.lookat(matrix, eye, target, up);
    matrix = mat.translate(matrix, [0, -this.distance, 0]);
    matrix = mat.rotateX(matrix, -this.rotation[0]);
    matrix = mat.rotateY(matrix, -this.rotation[1]);
    matrix = mat.rotateZ(matrix, -this.rotation[2]);
    matrix = mat.translate(matrix, vec.neg(this.position));
    return matrix;
  };
};

e3d = e3d || {};

e3d.init = function(canvas) {
  var gl;
  gl = canvas.getContext('experimental-webgl', {
    alpha: false
  });
  gl.enable(gl.DEPTH_TEST);
  e3d.width = canvas.width;
  e3d.height = canvas.height;
  e3d.gl = gl;
  e3d.scene = null;
  e3d.noTexture = new e3d.Texture(null);
  e3d.onrender = null;
  return e3d.program.mesh.init();
};

e3d.run = function() {
  var frame, requestAnimationFrame;
  requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 1000 / 60);
  };
  frame = function() {
    var gl;
    requestAnimationFrame(frame);
    gl = e3d.gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    if (e3d.scene != null) {
      e3d.scene.render();
    }
    if (e3d.onrender != null) {
      return e3d.onrender();
    }
  };
  return requestAnimationFrame(frame);
};

mat = {
  row: function(m, i) {
    return [m[i * 4 + 0], m[i * 4 + 1], m[i * 4 + 2], m[i * 4 + 3]];
  },
  col: function(m, i) {
    return [m[i + 4 * 0], m[i + 4 * 1], m[i + 4 * 2], m[i + 4 * 3]];
  },
  mul: function(a, b) {
    var c0, c1, c2, c3, dot, r0, r1, r2, r3;
    c0 = mat.col(a, 0);
    c1 = mat.col(a, 1);
    c2 = mat.col(a, 2);
    c3 = mat.col(a, 3);
    r0 = mat.row(b, 0);
    r1 = mat.row(b, 1);
    r2 = mat.row(b, 2);
    r3 = mat.row(b, 3);
    dot = vec.dot4;
    return [dot(c0, r0), dot(c1, r0), dot(c2, r0), dot(c3, r0), dot(c0, r1), dot(c1, r1), dot(c2, r1), dot(c3, r1), dot(c0, r2), dot(c1, r2), dot(c2, r2), dot(c3, r2), dot(c0, r3), dot(c1, r3), dot(c2, r3), dot(c3, r3)];
  },
  translate: function(m, v) {
    var t;
    t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
    return mat.mul(m, t);
  },
  scale: function(m, v) {
    var s;
    s = [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
    return mat.mul(m, s);
  },
  rotateX: function(m, a) {
    var c, r, s;
    s = Math.sin(a);
    c = Math.cos(a);
    r = [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1];
    return mat.mul(m, r);
  },
  rotateY: function(m, a) {
    var c, r, s;
    s = Math.sin(a);
    c = Math.cos(a);
    r = [c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1];
    return mat.mul(m, r);
  },
  rotateZ: function(m, a) {
    var c, r, s;
    s = Math.sin(a);
    c = Math.cos(a);
    r = [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    return mat.mul(m, r);
  },
  lookat: function(m, eye, target, up) {
    var dot, l, x, y, z;
    z = vec.unit(vec.sub(eye, target));
    x = vec.unit(vec.cross(z, up));
    y = vec.unit(vec.cross(x, z));
    dot = vec.dot;
    l = [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -dot(x, eye), -dot(y, eye), -dot(z, eye), 1];
    return mat.mul(m, l);
  },
  identity: function() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  },
  frustum: function(left, right, bottom, top, near, far) {
    var a00, a11, a20, a21, a22, a32;
    a00 = (near * 2) / (right - left);
    a11 = (near * 2) / (top - bottom);
    a20 = (right + left) / (right - left);
    a21 = (top + bottom) / (top - bottom);
    a22 = -(far + near) / (far - near);
    a32 = -(far * near * 2) / (far - near);
    return [a00, 0, 0, 0, 0, a11, 0, 0, a20, a21, a22, -1, 0, 0, a32, 0];
  },
  perspective: function(fovy, aspect, near, far) {
    var right, top;
    top = near * Math.tan(fovy * Math.PI / 360);
    right = top * aspect;
    return mat.frustum(-right, right, -top, top, near, far);
  }
};

e3d = e3d || {};

e3d.Mesh = function(data) {
  var gl, nvertices, program, vertexbuffer;
  gl = e3d.gl;
  program = e3d.program.mesh;
  vertexbuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexbuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
  nvertices = data.length / 8;
  this.render = function() {
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexbuffer);
    gl.vertexAttribPointer(program.aPositionLoc, 3, gl.FLOAT, false, 32, 0);
    gl.vertexAttribPointer(program.aTexCoordLoc, 2, gl.FLOAT, false, 32, 12);
    gl.vertexAttribPointer(program.aColorLoc, 3, gl.FLOAT, false, 32, 20);
    return gl.drawArrays(gl.TRIANGLES, 0, nvertices);
  };
};

e3d = e3d || {};

e3d.Object = function() {
  var gl, program;
  gl = e3d.gl;
  program = e3d.program.mesh;
  this.position = [0, 0, 0];
  this.rotation = [0, 0, 0];
  this.scale = [1, 1, 1];
  this.meshes = [];
  this.textures = [];
  this.children = [];
  this.render = function(matrix) {
    var child, i, mesh, _i, _j, _len, _len1, _ref, _ref1, _results;
    matrix = mat.translate(matrix, this.position);
    matrix = mat.rotateX(matrix, this.rotation[0]);
    matrix = mat.rotateY(matrix, this.rotation[1]);
    matrix = mat.rotateZ(matrix, this.rotation[2]);
    matrix = mat.scale(matrix, this.scale);
    program.setMatrix(matrix);
    e3d.noTexture.use();
    _ref = this.meshes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      mesh = _ref[i];
      if (mesh != null) {
        if (this.textures[i] != null) {
          this.textures[i].use();
        }
        mesh.render();
      }
    }
    _ref1 = this.children;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      child = _ref1[_j];
      if (child != null) {
        _results.push(child.render(matrix));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
};

e3d = e3d || {};

e3d.Scene = function() {
  var gl, program;
  gl = e3d.gl;
  program = e3d.program.mesh;
  this.objects = [];
  this.camera = null;
  this.render = function() {
    var matrix, object, _i, _len, _ref;
    if (this.camera != null) {
      program.begin();
      matrix = this.camera.createMatrix();
      _ref = this.objects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object != null) {
          object.render(matrix);
        }
      }
      return program.end();
    }
  };
};

e3d = e3d || {};

e3d.program = {
  mesh: {
    vertexSource: "uniform mat4 uMatrix;\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nattribute vec3 aColor;\nvarying vec2 vTexCoord;\nvarying vec3 vColor;\n\nvoid main() {\n\n  gl_Position = uMatrix * vec4(aPosition,1);\n  vTexCoord = aTexCoord;\n  vColor = aColor;\n\n}",
    fragmentSource: "precision mediump float;\n\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvarying vec3 vColor;\n\nvoid main() {\n\n  gl_FragColor = texture2D(uTexture, vTexCoord) * vec4(vColor,1);\n\n}",
    init: function() {
      var gl, me, program, uMatrixLoc, uTextureLoc;
      gl = e3d.gl;
      me = e3d.program.mesh;
      program = e3d.compileProgram(me.vertexSource, me.fragmentSource);
      uMatrixLoc = gl.getUniformLocation(program, 'uMatrix');
      uTextureLoc = gl.getUniformLocation(program, 'uTexture');
      me.aPositionLoc = gl.getAttribLocation(program, 'aPosition');
      me.aTexCoordLoc = gl.getAttribLocation(program, 'aTexCoord');
      me.aColorLoc = gl.getAttribLocation(program, 'aColor');
      gl.useProgram(program);
      gl.uniform1i(uTextureLoc, 0);
      gl.useProgram(null);
      me.setMatrix = function(matrix) {
        return gl.uniformMatrix4fv(uMatrixLoc, false, matrix);
      };
      me.begin = function() {
        gl.useProgram(program);
        gl.enableVertexAttribArray(me.aPositionLoc);
        gl.enableVertexAttribArray(me.aTexCoordLoc);
        return gl.enableVertexAttribArray(me.aColorLoc);
      };
      return me.end = function() {
        gl.disableVertexAttribArray(me.aPositionLoc);
        gl.disableVertexAttribArray(me.aTexCoordLoc);
        gl.disableVertexAttribArray(me.aColorLoc);
        return gl.useProgram(null);
      };
    }
  }
};

e3d.compileProgram = function(vertexSource, fragmentSource) {
  var compileShader, gl, program;
  gl = e3d.gl;
  compileShader = function(type, source) {
    var shader;
    shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.log(gl.getShaderInfoLog(shader));
      throw "compileShader fail!";
    }
    return shader;
  };
  program = gl.createProgram();
  gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexSource));
  gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentSource));
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log(gl.getProgramInfoLog(program));
    throw "linkProgram fail!";
  }
  return program;
};

e3d = e3d || {};

e3d.Texture = function(image) {
  var gl, pixels, program, texture;
  gl = e3d.gl;
  program = e3d.program.mesh;
  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  if (image != null) {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    this.width = image.width;
    this.height = image.height;
  } else {
    pixels = new Uint8Array([255, 255, 255, 255]);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    this.width = 0;
    this.height = 0;
  }
  this.use = function() {
    return gl.bindTexture(gl.TEXTURE_2D, texture);
  };
  this.free = function() {
    if (texture != null) {
      gl.deleteTexture(texture);
      return texture = null;
    }
  };
};

vec = {
  add: function(u, v) {
    return [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
  },
  sub: function(u, v) {
    return [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
  },
  mul: function(v, k) {
    return [v[0] * k, v[1] * k, v[2] * k];
  },
  div: function(v, k) {
    return [v[0] / k, v[1] / k, v[2] / k];
  },
  neg: function(v) {
    return [-v[0], -v[1], -v[2]];
  },
  dot: function(u, v) {
    return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
  },
  dot4: function(u, v) {
    return u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3];
  },
  cross: function(u, v) {
    return [u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0]];
  },
  len: function(v) {
    return Math.sqrt(vec.dot(v, v));
  },
  unit: function(v) {
    return vec.div(v, vec.len(v));
  }
};

boxMeshes = [];

boxTextures = [];

setBoxTextures = function(textures) {
  var index, texture, _i, _len, _results;
  _results = [];
  for (index = _i = 0, _len = textures.length; _i < _len; index = ++_i) {
    texture = textures[index];
    _results.push(boxTextures[index] = texture);
  }
  return _results;
};

BoxObject = function(x, y, z) {
  var object;
  if (boxMeshes.length === 0) {
    boxMeshes = [new e3d.Mesh(makeBox(0, 0, 0))];
  }
  object = new e3d.Object;
  object.meshes = boxMeshes;
  object.textures = boxTextures;
  object.position = [x, y, z];
  return object;
};

LevelView = function() {
  var camera, currState, imagefiles, scene;
  camera = new e3d.Camera;
  camera.distance = 12;
  camera.rotation = [0.5, 0, 0];
  scene = new e3d.Scene;
  scene.camera = camera;
  imagefiles = {
    'sky': ['/tex/sky.png'],
    'level': ['/tex/wall.png', '/tex/floor.png', '/tex/platform.png'],
    'box': ['/tex/box.png'],
    'lift': ['/tex/lift.png', '/tex/lifttop.png'],
    'player': ['/tex/player.png']
  };
  loadImageFiles(imagefiles, function(images) {
    setSkyTextures(createTextures(images['sky']));
    setLevelTextures(createTextures(images['level']));
    setBoxTextures(createTextures(images['box']));
    setLiftTextures(createTextures(images['lift']));
    setPlayerTextures(createTextures(images['player']));
    return e3d.scene = scene;
  });
  currState = null;
  this.update = function(levelState) {
    var boxGroup, center, levelModel, liftGroup, objects, player, skySphere;
    if (levelState !== currState) {
      currState = levelState;
      center = [levelState.width / 2, levelState.depth / 2, levelState.height / 2];
      camera.position = center;
      skySphere = new SkyObject;
      skySphere.position = center;
      levelModel = new StaticLevelObject(levelState);
      boxGroup = new e3d.Object;
      boxGroup.children = levelState.forEach('box', function(box, x, y, z) {
        return new BoxObject(x, y, z);
      });
      liftGroup = new e3d.Object;
      liftGroup.children = levelState.forEach('lift', function(lift, x, y, z) {
        return new LiftObject(x, y, z);
      });
      player = new PlayerObject(levelState.player);
      objects = [skySphere, levelModel, boxGroup, liftGroup, player];
      return scene.objects = objects;
    }
  };
};

liftMeshes = [];

liftTextures = [];

setLiftTextures = function(textures) {
  var index, texture, _i, _len, _results;
  _results = [];
  for (index = _i = 0, _len = textures.length; _i < _len; index = ++_i) {
    texture = textures[index];
    _results.push(liftTextures[index] = texture);
  }
  return _results;
};

LiftObject = function(x, y, z) {
  var object;
  if (liftMeshes.length === 0) {
    liftMeshes = [new e3d.Mesh(makeLidlessBox(0, 0, 0)), new e3d.Mesh(makeTopFace(0, 0, 0))];
  }
  object = new e3d.Object;
  object.meshes = liftMeshes;
  object.textures = liftTextures;
  object.position = [x, y, z];
  return object;
};

playerMeshes = [];

playerTextures = [];

setPlayerTextures = function(textures) {
  var index, texture, _i, _len, _results;
  _results = [];
  for (index = _i = 0, _len = textures.length; _i < _len; index = ++_i) {
    texture = textures[index];
    _results.push(playerTextures[index] = texture);
  }
  return _results;
};

PlayerObject = function(player) {
  var object;
  if (playerMeshes.length === 0) {
    playerMeshes = [new e3d.Mesh(makeBox(0, 0, 0))];
  }
  object = new e3d.Object;
  object.meshes = playerMeshes;
  object.textures = playerTextures;
  object.position = player.position;
  return object;
};

skyMeshes = [];

skyTextures = [];

setSkyTextures = function(textures) {
  var index, texture, _i, _len, _results;
  _results = [];
  for (index = _i = 0, _len = textures.length; _i < _len; index = ++_i) {
    texture = textures[index];
    _results.push(skyTextures[index] = texture);
  }
  return _results;
};

SkyObject = function(x, y, z) {
  var object;
  if (skyMeshes.length === 0) {
    skyMeshes[0] = null;
    loadJsonFile('mod/sky.json', function(sky) {
      return skyMeshes[0] = new e3d.Mesh(sky);
    });
  }
  object = new e3d.Object;
  object.meshes = skyMeshes;
  object.textures = skyTextures;
  object.position = [x, y, z];
  object.scale = [80, 80, 80];
  return object;
};

levelTextures = [];

setLevelTextures = function(textures) {
  var index, texture, _i, _len, _results;
  _results = [];
  for (index = _i = 0, _len = textures.length; _i < _len; index = ++_i) {
    texture = textures[index];
    _results.push(levelTextures[index] = texture);
  }
  return _results;
};

StaticLevelObject = function(levelState) {
  var depth, ground, object, platformTop, side, solidTop, width;
  width = levelState.width;
  depth = levelState.depth;
  ground = [];
  side = [];
  solidTop = [];
  platformTop = [];
  levelState.forEachBlockInLayer(0, function(block, x, y) {
    if (!block["static"]) {
      ground = ground.concat(makeTopFace(x, y, -1));
    }
    if (x === 0) {
      ground = ground.concat(makeTopFace(-1, y, -1));
    }
    if (x === width - 1) {
      ground = ground.concat(makeTopFace(x + 1, y, -1));
    }
    if (y === 0) {
      ground = ground.concat(makeTopFace(x, -1, -1));
    }
    if (y === depth - 1) {
      ground = ground.concat(makeTopFace(x, y + 1, -1));
    }
    if (x === 0 && y === 0) {
      ground = ground.concat(makeTopFace(-1, -1, -1));
    }
    if (x === width - 1 && y === 0) {
      ground = ground.concat(makeTopFace(x + 1, -1, -1));
    }
    if (x === 0 && y === depth - 1) {
      ground = ground.concat(makeTopFace(-1, y + 1, -1));
    }
    if (x === width - 1 && y === depth - 1) {
      return ground = ground.concat(makeTopFace(x + 1, y + 1, -1));
    }
  });
  levelState.forEachBlock(function(block, x, y, z) {
    var backBlock, frontBlock, leftBlock, rightBlock, topBlock;
    if (block["static"]) {
      leftBlock = levelState.blockAt(x - 1, y, z);
      rightBlock = levelState.blockAt(x + 1, y, z);
      backBlock = levelState.blockAt(x, y - 1, z);
      frontBlock = levelState.blockAt(x, y + 1, z);
      topBlock = levelState.blockAt(x, y, z + 1);
      if (!leftBlock["static"]) {
        side = side.concat(makeLeftFace(x, y, z));
      }
      if (!rightBlock["static"]) {
        side = side.concat(makeRightFace(x, y, z));
      }
      if (!backBlock["static"]) {
        side = side.concat(makeBackFace(x, y, z));
      }
      if (!frontBlock["static"]) {
        side = side.concat(makeFrontFace(x, y, z));
      }
      if (!topBlock["static"]) {
        if (block.type === 'solid') {
          solidTop = solidTop.concat(makeTopFace(x, y, z));
        }
        if (block.type === 'platform') {
          return platformTop = platformTop.concat(makeTopFace(x, y, z));
        }
      }
    }
  });
  object = new e3d.Object;
  object.meshes = [new e3d.Mesh(side), new e3d.Mesh(solidTop), new e3d.Mesh(platformTop)];
  object.textures = levelTextures;
  return object;
};

createTextures = function(images) {
  var image, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = images.length; _i < _len; _i++) {
    image = images[_i];
    _results.push(new e3d.Texture(image));
  }
  return _results;
};

makeQuad = function(positions, color) {
  var b, g, p, r, v;
  p = positions;
  r = color[0];
  g = color[1];
  b = color[2];
  v = [[p[0][0], p[0][1], p[0][2], 0, 0, r, g, b], [p[1][0], p[1][1], p[1][2], 1, 0, r, g, b], [p[2][0], p[2][1], p[2][2], 0, 1, r, g, b], [p[3][0], p[3][1], p[3][2], 1, 1, r, g, b]];
  return [].concat(v[0], v[1], v[2], v[3], v[2], v[1]);
};

makeLeftFace = function(x, y, z) {
  var color, positions;
  positions = [[x, y, z + 1], [x, y + 1, z + 1], [x, y, z], [x, y + 1, z]];
  color = [0.7, 0.7, 0.7];
  return makeQuad(positions, color);
};

makeRightFace = function(x, y, z) {
  var color, positions;
  positions = [[x + 1, y + 1, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z], [x + 1, y, z]];
  color = [0.8, 0.8, 0.8];
  return makeQuad(positions, color);
};

makeBackFace = function(x, y, z) {
  var color, positions;
  positions = [[x + 1, y, z + 1], [x, y, z + 1], [x + 1, y, z], [x, y, z]];
  color = [0.6, 0.6, 0.6];
  return makeQuad(positions, color);
};

makeFrontFace = function(x, y, z) {
  var color, positions;
  positions = [[x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z], [x + 1, y + 1, z]];
  color = [0.9, 0.9, 0.9];
  return makeQuad(positions, color);
};

makeTopFace = function(x, y, z) {
  var color, positions;
  positions = [[x, y, z + 1], [x + 1, y, z + 1], [x, y + 1, z + 1], [x + 1, y + 1, z + 1]];
  color = [1.0, 1.0, 1.0];
  return makeQuad(positions, color);
};

makeLidlessBox = function(x, y, z) {
  return [].concat(makeLeftFace(x, y, z), makeRightFace(x, y, z), makeBackFace(x, y, z), makeFrontFace(x, y, z));
};

makeBox = function(x, y, z) {
  return [].concat(makeLidlessBox(x, y, z), makeTopFace(x, y, z));
};

View = function(canvas) {
  e3d.init(canvas);
  this.level = null;
  return this.update = function(context) {};
};
